<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="ä½œæ¯æ™‚é˜">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />

<title>å¯¶å¯¶ä½œæ¯æ™‚é˜ - é›²ç«¯åŒæ­¥ç‰ˆ</title>
<style>
  /* å…¨åŸŸè¨­å®š */
  body, html {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #fffafc;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    position: relative;
  }

  .clock {
    position: relative;
    width: 380px;
    height: 380px;
    border-radius: 50%;
    box-shadow: 0 0 50px rgba(0,0,0,0.15);
    margin-bottom: 20px; 
    transition: background 0.5s ease-in-out; 
  }

  /* æ™‚é˜æŒ‡é‡èˆ‡ä¸­å¿ƒé» */
  /* å°‡æŒ‡é‡çš„ top èª¿æ•´åˆ°åœ“å¿ƒä¸Šæ–¹ï¼Œè®“æ—‹è½‰ä¸­å¿ƒåœ¨åº•éƒ¨ */
  .minute-hand { 
    position: absolute; 
    width: 6px; 
    height: 160px; 
    background: #333; 
    top: 30px; 
    left: 50%; 
    transform-origin: bottom center; 
    border-radius: 3px; 
    z-index: 10; 
  }
  .center-dot { position: absolute; width: 16px; height: 16px; background: #333; border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 11; border: 2px solid white; }

  /* ä»»å‹™æ¨™ç±¤ */
  .task-label { position: absolute; font-size: 13px; font-weight: 500; text-align: center; transform: translate(-50%, -50%); z-index: 5; line-height: 1.3; color: #444; text-shadow: 0 1px 2px rgba(255,255,255,0.9); pointer-events: none; }
  
  /* åˆ»åº¦èˆ‡æ•¸å­— */
  .tick { position: absolute; left: 50%; top: 0; background: rgba(0, 0, 0, 0.3); transform-origin: 50% 190px; }
  .tick.minor { width: 1px; height: 6px; }
  .tick.major { width: 3px; height: 12px; background: rgba(0, 0, 0, 0.6); }
  
  .clock-label { position: absolute; font-weight: 800; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 6; font-feature-settings: "tnum"; pointer-events: none; }
  .hour-number { font-size: 24px; color: #222; } 
  .zoom-minute-label { font-size: 18px; color: #666; } 

  /* æ™‚é–“é¡¯ç¤ºæ¡† */
  .current-time-box { background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); padding: 15px 40px; border-radius: 25px; box-shadow: 0 5px 15px rgba(0,0,0,0.05); text-align: center; border: 1px solid rgba(255,255,255,0.5); }
  .current-time { font-size: 40pt; font-weight: bold; color: #333; font-variant-numeric: tabular-nums; line-height: 1; }
  .date-label { font-size: 14pt; color: #888; margin-bottom: 8px; font-weight: 500; }
  .mode-indicator { font-size: 14pt; font-weight: bold; margin-top: 5px; }

  /* --- æ¨¡å¼åˆ‡æ›æŒ‰éˆ• --- */
  #modeToggleButton {
    background: #007aff;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 10px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    margin-bottom: 20px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
  }
  
  /* --- è¨­å®šæŒ‰éˆ•èˆ‡å½ˆçª—æ¨£å¼ --- */
  #settingsBtn { position: absolute; top: 20px; right: 20px; background: white; padding: 10px; border-radius: 50%; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); font-size: 24px; line-height: 1; cursor: pointer; z-index: 50; }
  #settingsModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); z-index: 100; display: none; justify-content: center; align-items: center; overflow-y: auto; padding: 20px 0; }
  .modal-content { background: white; border-radius: 20px; width: 95%; max-width: 900px; max-height: 95%; overflow-y: auto; padding: 20px 30px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); }
  .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
  .modal-header h2 { color: #333; font-size: 28px; }
  .modal-actions button, .preset-actions button { padding: 10px 20px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; margin-left: 10px; }
  #saveSettingsBtn { background: #4CAF50; color: white; }
  #closeSettingsBtn { background: #f44336; color: white; }
  #loadPresetBtn { background: #2196F3; color: white; }
  #savePresetBtn { background: #FF9800; color: white; }
  #deletePresetBtn { background: #F44336; color: white; }
  #tasksTable { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 14px; }
  #tasksTable th, #tasksTable td { padding: 10px 5px; text-align: center; border-bottom: 1px solid #eee; }
  #tasksTable input[type="text"] { padding: 5px; border: 1px solid #ccc; border-radius: 5px; width: 100%; box-sizing: border-box; }
  #tasksTable input[type="color"] { width: 30px; height: 30px; padding: 0; border: none; border-radius: 5px; vertical-align: middle; }
  .time-select-group { display: flex; gap: 3px; justify-content: center; }
  .time-select-group select { width: 45%; padding: 5px; border: 1px solid #ccc; border-radius: 5px; }
  .preset-actions { display: flex; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; }
</style>
</head>
<body>

<div id="settingsBtn">âš™ï¸</div>

<button id="modeToggleButton"></button>

<div id="clock" class="clock">
  <div class="minute-hand" id="minHand"></div>
  <div class="center-dot"></div>
</div>

<div class="current-time-box">
  <div id="date-label" class="date-label"></div>
  <div id="current-time" class="current-time"></div>
  <div id="mode-indicator" class="mode-indicator"></div>
</div>

<div id="settingsModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>ä½œæ¯æ’ç¨‹è¨­å®š (åˆ†é˜ç²’åº¦)</h2>
            <div class="modal-actions">
                <button id="saveSettingsBtn">ğŸ’¾ å„²å­˜ä¸¦æ›´æ–°</button>
                <button id="closeSettingsBtn">âŒ é—œé–‰</button>
            </div>
        </div>
        
        <h3>è¨˜æ†¶çµ„ (Preset) ç®¡ç†</h3>
        <div class="preset-actions">
            <label>è¼‰å…¥/åˆ‡æ›ï¼š</label>
            <select id="presetSelector"></select>
            <button id="loadPresetBtn">è®€å–ä¸¦è¦†è“‹</button>
            <button id="deletePresetBtn">åˆªé™¤é¸å®šçµ„</button>
            
            <label style="margin-left: 20px;">å„²å­˜ç›®å‰ï¼š</label>
            <input type="text" id="newPresetName" placeholder="è¼¸å…¥æ–°è¨˜æ†¶çµ„åç¨±" style="width: 150px;"/>
            <button id="savePresetBtn">ğŸ’¾ å„²å­˜ç‚ºæ–°çµ„</button>
        </div>

        <h3>ä»»å‹™åˆ—è¡¨è¨­å®š (æœ€å¤š 10 çµ„)</h3>
        <p style="color: red; font-weight: bold;">âš ï¸ æ™‚é–“ä¸å¯é‡ç–Šï¼ŒçµæŸæ™‚é–“å¿…é ˆå¤§æ–¼é–‹å§‹æ™‚é–“ (è·¨æ—¥é™¤å¤–)ï¼</p>
        <table id="tasksTable">
            <thead>
                <tr>
                    <th>#</th>
                    <th>å•Ÿç”¨</th>
                    <th>ä»»å‹™åç¨±</th>
                    <th>Emoji</th>
                    <th>é¡è‰²</th>
                    <th>é–‹å§‹æ™‚é–“ (å°æ™‚:åˆ†é˜)</th>
                    <th>çµæŸæ™‚é–“ (å°æ™‚:åˆ†é˜)</th>
                </tr>
            </thead>
            <tbody id="tasksBody">
                </tbody>
        </table>
        
        <h3 style="margin-top: 20px;">è·¨è£ç½®åŒæ­¥è³‡è¨Š (è«‹è¤‡è£½æ­¤ç¶²å€)</h3>
        <p>è«‹å°‡ä¸‹æ–¹ç¶²å€è¤‡è£½åˆ°æ‚¨æ‰€æœ‰è£ç½®ï¼Œå³å¯åŒæ­¥æ‚¨çš„è¨­å®šï¼š</p>
        <input type="text" id="syncUrlDisplay" style="width: 100%; padding: 10px; font-size: 14px; border: 1px solid #ccc; border-radius: 5px;" readonly>
    </div>
</div>

<script>
// --- é›²ç«¯åŒæ­¥è¨­å®š (è«‹å‹™å¿…ç¢ºèªé€™å…©å€‹åƒæ•¸æ˜¯æ‚¨è‡ªå·±çš„) ---
// ğŸš¨ 401 Unauthorized éŒ¯èª¤é€šå¸¸ç™¼ç”Ÿåœ¨ Key æˆ– Bin ID ä¸æ­£ç¢ºæ™‚ã€‚
const X_MASTER_KEY = '$2a$10$Ud6ejIFrOHIeYjhVKcVE5.PG9rQKTWbsvFd0RuYmxubPyt2bjV5yS'; 
const BIN_ID = '6923f5dcd0ea881f40fc4e32';
const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;

// --- æ ¸å¿ƒæ•¸æ“šèˆ‡æ¨¡å¼è¨­å®š ---
const LOCAL_STORAGE_CONTROL_KEY = 'controlMode'; 
const MAX_TASKS = 10;
const FULL_DAY_MINUTES = 1440; 
const FULL_DAY_DEGREE = 360 / FULL_DAY_MINUTES; // 0.25 åº¦/åˆ†é˜
const ZOOM_DEGREE = 360 / 60; // 6 åº¦/åˆ†é˜

// æ¨¡å¼å®šç¾©
const MODE_AUTO = 'ZOOM_FORCED'; 
const MODE_FORCED_FULL = 'FULLDAY_FORCED'; 

// é è¨­æ•¸æ“š (é›²ç«¯è¼‰å…¥å¤±æ•—æ™‚ä½¿ç”¨)
const DEFAULT_TASKS = [
    { name: 'èµ·åºŠ', emoji: 'ğŸŒ', color: '#ffd6e8', start: 420, end: 510, enabled: true },      
    { name: 'ä¸Šå­¸', emoji: 'ğŸ’', color: '#fdd9c7', start: 510, end: 1020, enabled: true },    
    { name: 'å›å®¶', emoji: 'ğŸ ', color: '#ffecc7', start: 1020, end: 1140, enabled: true },    
    { name: 'æ´—æ¾¡', emoji: 'ğŸ›', color: '#d6eaff', start: 1140, end: 1260, enabled: true },    
    { name: 'ç¡è¦º', emoji: 'ğŸ˜´', color: '#e5ffd6', start: 1260, end: 420, enabled: true },      
    { name: '', emoji: '', color: '#e8d6ff', start: 0, end: 0, enabled: false },  
    { name: '', emoji: '', color: '#ffdfd6', start: 0, end: 0, enabled: false },    
    { name: '', emoji: '', color: '#ffc7d9', start: 0, end: 0, enabled: false },  
    { name: '', emoji: '', color: '#c7d9ff', start: 0, end: 0, enabled: false },    
    { name: '', emoji: '', color: '#f0f0f0', start: 0, end: 0, enabled: false }               
];
const DEFAULT_PRESET_NAME = 'é è¨­ä½œæ¯';
const DEFAULT_CLOUD_DATA = { 
    tasks: DEFAULT_TASKS,
    presets: { [DEFAULT_PRESET_NAME]: DEFAULT_TASKS }
};


let currentTasks = [];
let presets = {};
let displayMode = 'FULL_DAY'; 
let controlMode = MODE_FORCED_FULL; 
let zoomStartMinutes = 0; 
let configId = BIN_ID; 


// --- æ™‚é–“è™•ç†èˆ‡å·¥å…·å‡½å¼ ---

// å°‡åˆ†é˜æ•¸è½‰æ›ç‚º HH:MM å­—ä¸²
function minutesToHHMM(totalMinutes) {
    if (totalMinutes === 1440) return '24:00';
    totalMinutes = totalMinutes % 1440;
    const hour = Math.floor(totalMinutes / 60);
    const minute = totalMinutes % 60;
    return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
}

// å°‡ç¸½åˆ†é˜æ•¸è½‰æ›ç‚ºå°æ™‚å’Œåˆ†é˜å°è±¡
function minutesToTime(totalMinutes) {
    if (typeof totalMinutes !== 'number' || isNaN(totalMinutes) || totalMinutes < 0) {
        totalMinutes = 0; 
    }
    
    // 24:00 è™•ç†
    if (totalMinutes === 1440) return { hour: 24, minute: 0 }; 
    const hour = Math.floor(totalMinutes / 60) % 24;
    const minute = totalMinutes % 60;
    return { hour, minute };
}

// å‹•æ…‹ç”Ÿæˆæ™‚é–“é¸æ“‡å™¨ HTML
function generateTimeSelectors(dataIndex, fieldPrefix, totalMinutes, isEnd) {
    if (typeof totalMinutes !== 'number' || isNaN(totalMinutes) || totalMinutes < 0) {
        totalMinutes = 0; 
    }
    let { hour, minute } = minutesToTime(totalMinutes);
    
    let hourOptions = '';
    const maxHour = isEnd ? 24 : 23; 
    for (let h = 0; h <= maxHour; h++) {
        hourOptions += `<option value="${h}" ${h === hour ? 'selected' : ''}>${h.toString().padStart(2, '0')}</option>`;
    }

    let minuteOptions = '';
    // åªæä¾› 5 åˆ†é˜çš„ç²’åº¦é¸æ“‡
    for (let m = 0; m <= 59; m += 5) { 
        minuteOptions += `<option value="${m}" ${m === minute ? 'selected' : ''}>${m.toString().padStart(2, '0')}</option>`;
    }
    
    return `<div class="time-select-group">
        <select data-index="${dataIndex}" data-field="${fieldPrefix}Hour">${hourOptions}</select>
        <select data-index="${dataIndex}" data-field="${fieldPrefix}Minute">${minuteOptions}</select>
    </div>`;
}


// --- æ•¸æ“šè¼‰å…¥/å„²å­˜é‚è¼¯ ---

async function loadData() {
    const savedControl = localStorage.getItem(LOCAL_STORAGE_CONTROL_KEY);
    controlMode = savedControl || MODE_FORCED_FULL; 

    try {
        const response = await fetch(JSONBIN_URL, {
            headers: {
                'X-Master-Key': X_MASTER_KEY,
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`Cloud load failed: ${response.status} (${response.statusText})`);
        }
        
        const data = await response.json();
        const cloudData = data.record; 

        if (cloudData && cloudData.tasks && cloudData.presets) {
            currentTasks = cloudData.tasks;
            presets = cloudData.presets;
            console.log("æ•¸æ“šå¾é›²ç«¯è¼‰å…¥æˆåŠŸã€‚");
        } else {
            currentTasks = DEFAULT_TASKS;
            presets = DEFAULT_CLOUD_DATA.presets;
            console.log("é›²ç«¯æ•¸æ“šçµæ§‹éŒ¯èª¤æˆ–ç©ºç™½ï¼Œä½¿ç”¨é è¨­å€¼ã€‚");
        }
        
    } catch (error) {
        console.error("è¼‰å…¥é›²ç«¯æ•¸æ“šæ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œä½¿ç”¨é è¨­å€¼:", error);
        currentTasks = DEFAULT_TASKS;
        presets = DEFAULT_CLOUD_DATA.presets;
    }
}


async function saveCloudData(tasksToSave, presetsToSave) {
    const payload = { 
        tasks: tasksToSave,
        presets: presetsToSave
    };

    try {
        const response = await fetch(JSONBIN_URL, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Master-Key': X_MASTER_KEY,
                'X-Bin-Versioning': false 
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            throw new Error(`Cloud save failed: ${response.status} (${response.statusText})`);
        }
        
        console.log("æ•¸æ“šæˆåŠŸåŒæ­¥åˆ°é›²ç«¯ã€‚");
        updateSyncUrlDisplay();
        return true;
    } catch (error) {
        console.error("å„²å­˜é›²ç«¯æ•¸æ“šæ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
        alert('âŒ é›²ç«¯åŒæ­¥å¤±æ•—ï¼è«‹æª¢æŸ¥æ‚¨çš„ API Key å’Œ Bin ID æ˜¯å¦æ­£ç¢ºã€‚');
        return false;
    }
}

function updateSyncUrlDisplay() {
    const baseUrl = window.location.href.split('?')[0];
    document.getElementById('syncUrlDisplay').value = `${baseUrl}?configId=${configId}`;
}

function updateModeButton() {
    const btn = document.getElementById('modeToggleButton');
    if (controlMode === MODE_AUTO) {
        btn.textContent = 'ğŸ” ç›®å‰: å°æ™‚ç¸®æ”¾ (é»æ“Šåˆ‡æ› 24 å°æ™‚å…¨æ™¯)'; 
    } else {
        btn.textContent = 'ğŸ‘ï¸â€ğŸ—¨ï¸ ç›®å‰: 24 å°æ™‚å…¨æ™¯ (é»æ“Šåˆ‡æ› å°æ™‚ç¸®æ”¾)';
    }
}

function saveControlMode() {
    localStorage.setItem(LOCAL_STORAGE_CONTROL_KEY, controlMode);
    updateModeButton();
}


// --- æ™‚é˜æ¸²æŸ“é‚è¼¯ (ä¿®æ­£åœ“ç’°é¡è‰²ä½ç½®) ---
const clockElement = document.getElementById('clock');
const modeIndicator = document.getElementById('mode-indicator');
const cx = 190; const cy = 190; // æ™‚é˜ä¸­å¿ƒé» (Clock width/height is 380px)
const R_TASK_LABEL = 85; // ä»»å‹™æ¨™ç±¤åŠå¾‘
const R_CLOCK_LABEL = 135; // æ•¸å­—æ¨™ç±¤åŠå¾‘

function renderClock() {
    // æ¯æ¬¡é‡æ–°ç¹ªè£½ï¼Œæ¸…é™¤èˆŠçš„å…§å®¹
    clockElement.innerHTML = `<div class="minute-hand" id="minHand"></div><div class="center-dot"></div>`;
    
    let conicGradientStops = [];
    let enabledTasks = currentTasks.filter(t => t.enabled);
    
    let degreePerMinute, startMinuteOffset;
    
    // --- 1. è¨­ç½®æ¨¡å¼åƒæ•¸ ---
    if (displayMode === 'FULL_DAY') {
        degreePerMinute = FULL_DAY_DEGREE;
        startMinuteOffset = 0;
        modeIndicator.textContent = 'é¡¯ç¤ºæ¨¡å¼ï¼š24 å°æ™‚ä½œæ¯ç’°';
    } else { // ZOOM Mode
        degreePerMinute = ZOOM_DEGREE;
        startMinuteOffset = zoomStartMinutes; 
        const zoomEndMinutes = zoomStartMinutes + 60;
        modeIndicator.textContent = `é¡¯ç¤ºæ¨¡å¼ï¼šå°æ™‚ç¸®æ”¾ (${minutesToHHMM(zoomStartMinutes)} - ${minutesToHHMM(zoomEndMinutes)})`;
    }

    // --- 2. è™•ç†ä»»å‹™å’Œè§’åº¦è¨ˆç®— ---
    enabledTasks.forEach(task => {
        let originalStart = task.start;
        let originalEnd = task.end;
        let taskDuration = originalEnd - originalStart;

        // è™•ç†è·¨æ—¥ä»»å‹™ (End < Start)
        if (taskDuration <= 0) {
            taskDuration += FULL_DAY_MINUTES;
            originalEnd += FULL_DAY_MINUTES; 
        }
        
        // ä»»å‹™å¯èƒ½éœ€è¦è¢«åˆ†è§£æˆå¤šå€‹å€æ®µ (ä¾‹å¦‚è·¨åˆå¤œ)
        let segments = [];
        let currentSegmentStart = originalStart;
        
        while (currentSegmentStart < originalEnd) {
            let nextBoundary = Math.ceil(currentSegmentStart / FULL_DAY_MINUTES) * FULL_DAY_MINUTES;
            let segmentEnd = Math.min(originalEnd, nextBoundary);
            
            segments.push({
                start: currentSegmentStart % FULL_DAY_MINUTES,
                end: segmentEnd % FULL_DAY_MINUTES,
                originalDuration: segmentEnd - currentSegmentStart,
                isWrapped: segmentEnd > FULL_DAY_MINUTES 
            });

            currentSegmentStart = segmentEnd;
        }

        let largestDuration = 0;
        let labelMiddleMinutes = 0; 

        // éæ­·æ‰€æœ‰å€æ®µ (é€šå¸¸åªæœ‰ä¸€å€‹ï¼Œè·¨æ—¥æœƒæœ‰å…©å€‹)
        segments.forEach(segment => {
            let start = segment.start;
            let end = segment.end;
            
            // è™•ç† 24:00 (0) çš„æƒ…æ³ï¼Œåœ¨è¨ˆç®—ä¸­è¦–ç‚º 1440
            if (end === 0 && segment.isWrapped) {
                end = FULL_DAY_MINUTES; 
            }
            
            let duration = end - start;
            if (duration <= 0) return; 

            let relativeStartMinutes, relativeEndMinutes;

            if (displayMode === 'FULL_DAY') {
                relativeStartMinutes = start; 
                relativeEndMinutes = end;
                duration = relativeEndMinutes - relativeStartMinutes;
                
            } else { // 1H ZOOM æ¨¡å¼
                const zoomEndMinutes = startMinuteOffset + 60;
                
                let clippedStart = Math.max(start, startMinuteOffset);
                let clippedEnd = Math.min(end, zoomEndMinutes);
                
                // è™•ç†è·¨æ—¥ä»»å‹™åœ¨ç•¶å‰å°æ™‚çš„é‚Šç•Œ
                if (start > end && start > startMinuteOffset) {
                    clippedStart = startMinuteOffset; 
                }
                
                if (clippedEnd <= clippedStart) return; 
                
                relativeStartMinutes = clippedStart - startMinuteOffset; // è½‰æ›åˆ° 0-60 å€é–“
                relativeEndMinutes = clippedEnd - startMinuteOffset;     // è½‰æ›åˆ° 0-60 å€é–“
                duration = relativeEndMinutes - relativeStartMinutes;
            }
            
            // 3. è½‰æ›ç‚ºè§’åº¦ï¼šè®“ 00:00 å°é½Š 0 åº¦ (12 é»æ–¹å‘)ã€‚
            let startDeg = relativeStartMinutes * degreePerMinute;
            let stopDeg = startDeg + (duration * degreePerMinute);

            // ç¢ºä¿ conic-gradient è§’åº¦æ˜¯ 0 åˆ° 360 ä¹‹é–“çš„æœ‰æ•ˆå€¼
            startDeg = startDeg % 360;
            if (startDeg < 0) startDeg += 360;

            conicGradientStops.push(`${task.color} ${startDeg}deg ${stopDeg}deg`);
            
            
            // 4. æ¨™ç±¤ä½ç½®ï¼š (è¨ˆç®—è§’åº¦æ™‚ä¸éœ€åç§» -90 åº¦)
            if (duration > largestDuration) {
                largestDuration = duration;
                labelMiddleMinutes = relativeStartMinutes + duration / 2;
            }
        });
        
        // 5. ç¹ªè£½æ¨™ç±¤ 
        if (task.name && task.emoji && largestDuration > 0) { 
            // æ¨™ç±¤çš„è§’åº¦ä¿®æ­£ï¼šæ¸›å» 90 åº¦ï¼Œå°‡åœ“ç’°åº§æ¨™ç³»çµ± (0åº¦åœ¨é ‚éƒ¨) è½‰æ›ç‚ºæ¨™æº–æ•¸å­¸åº§æ¨™ (0åº¦åœ¨å³å´) 
            let middleAngleDeg = labelMiddleMinutes * degreePerMinute;
            let middleAngleRad = (middleAngleDeg - 90) * Math.PI / 180;
            
            const div = document.createElement('div');
            div.className = 'task-label';
            
            // æ¨™ç±¤é¡¯ç¤ºå„ªåŒ–
            if (largestDuration < 10 && displayMode === 'ZOOM') {
                 div.innerHTML = `${task.emoji}`;
            } else {
                 div.innerHTML = `${task.emoji}<br>${task.name}`;
            }
           
            div.style.left = `${cx + R_TASK_LABEL * Math.cos(middleAngleRad)}px`;
            div.style.top = `${cy + R_TASK_LABEL * Math.sin(middleAngleRad)}px`;
            clockElement.appendChild(div);
        }
    });

    // è¨­ç½®åœ“ç’°èƒŒæ™¯
    clockElement.style.background = `conic-gradient(${conicGradientStops.join(', ')})`;
    
    // --- 6. ç¹ªè£½åˆ»åº¦èˆ‡æ•¸å­— ---
    if (displayMode === 'FULL_DAY') {
        for (let h = 1; h <= 12; h++) {
          const num = document.createElement('div');
          num.className = 'clock-label hour-number';
          num.textContent = h;
          // æ•¸å­—ä½ç½®ï¼šè§’åº¦éœ€è¦åç§» 90 åº¦ (å°‡æ™‚é˜è§’åº¦è½‰ç‚ºæ•¸å­¸è§’åº¦)
          const angle = (h * 30 - 90) * Math.PI / 180; 
          num.style.left = `${cx + R_CLOCK_LABEL * Math.cos(angle)}px`;
          num.style.top = `${cy + R_CLOCK_LABEL * Math.sin(angle)}px`;
          clockElement.appendChild(num);
        }
        for (let i = 0; i < 60; i++) {
            const tick = document.createElement('div');
            tick.className = 'tick ' + (i % 5 === 0 ? 'major' : 'minor');
            // åˆ»åº¦æ—‹è½‰ä¸éœ€è¦åç§»ï¼Œå®ƒæ˜¯ç›¸å°æ–¼é ‚éƒ¨çš„ 0 åº¦
            tick.style.transform = `translateX(-50%) rotate(${i * 6}deg)`;
            clockElement.appendChild(tick);
        }

    } else { 
        const hour = Math.floor(zoomStartMinutes / 60);
        for (let i = 0; i < 60; i += 5) {
            const isMajor = i % 15 === 0;
            const labelText = i.toString().padStart(2, '0');
            const deg = i * 6; 
            // æ•¸å­—ä½ç½®ï¼šè§’åº¦éœ€è¦åç§» 90 åº¦
            const angleRad = (deg - 90) * Math.PI / 180; 
            
            const tick = document.createElement('div');
            tick.className = 'tick ' + (isMajor ? 'major' : 'minor');
            tick.style.transform = `translateX(-50%) rotate(${deg}deg)`;
            clockElement.appendChild(tick);
            
            if (isMajor) {
                const num = document.createElement('div');
                num.className = 'clock-label zoom-minute-label';
                // ç‚ºäº†ä¸è®“æ¨™ç±¤æ–‡å­—å¤ªé•·ï¼Œåªé¡¯ç¤ºåˆ†é˜æ•¸
                num.textContent = `${labelText}`; 
                num.style.left = `${cx + R_CLOCK_LABEL * Math.cos(angleRad)}px`;
                num.style.top = `${cy + R_CLOCK_LABEL * Math.sin(angleRad)}px`;
                clockElement.appendChild(num);
            }
        }
    }
}


// updateTime æ ¸å¿ƒé‚è¼¯ (ä¿®æ­£æŒ‡é‡è§’åº¦)
function updateTime() {
    const now = new Date();
    const h = now.getHours();
    const m = now.getMinutes();
    const s = now.getSeconds();
    
    // ç¸½åˆ†é˜æ•¸ (åŒ…å«ç§’æ•¸)
    const currentTotalMinutes = (h * 60) + m + (s / 60);
    const currentHourStart = Math.floor(currentTotalMinutes / 60) * 60; 
    
    let newDisplayMode = 'FULL_DAY';

    if (controlMode === MODE_FORCED_FULL) {
        newDisplayMode = 'FULL_DAY';
        zoomStartMinutes = 0; 
    } else { // å¼·åˆ¶ç¸®æ”¾æ¨¡å¼
        newDisplayMode = 'ZOOM';
        zoomStartMinutes = currentHourStart; 
    }

    if (newDisplayMode !== displayMode) {
        displayMode = newDisplayMode;
        renderClock();
    }
    
    let rotationDegree = 0;
    if (displayMode === 'FULL_DAY') {
        // 24H æ¨¡å¼ä¸‹ï¼šç¸½åˆ†é˜æ•¸ * 0.25 åº¦/åˆ†é˜ã€‚
        // æ¸›å» 90 åº¦ï¼Œè®“ 00:00 çš„æŒ‡é‡å¾ 12 é»é˜æ–¹å‘é–‹å§‹ (CSS 0 åº¦æ˜¯ 3 é»é˜æ–¹å‘)ã€‚
        rotationDegree = currentTotalMinutes * FULL_DAY_DEGREE - 90;
    } else { 
        // 1H ç¸®æ”¾æ¨¡å¼ä¸‹ï¼šç•¶å‰å°æ™‚å…§çš„åˆ†é˜æ•¸ * 6 åº¦/åˆ†é˜ã€‚
        const minutesInHour = currentTotalMinutes - zoomStartMinutes;
        rotationDegree = minutesInHour * ZOOM_DEGREE - 90;
    }
    
    document.getElementById('minHand').style.transform = `translateX(-50%) rotate(${rotationDegree}deg)`;
    
    document.getElementById('current-time').textContent = 
        `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    const dateStr = now.toLocaleDateString('zh-TW', { month: 'long', day: 'numeric', weekday: 'long' });
    document.getElementById('date-label').textContent = dateStr;
}


// --- è¨­å®šä»‹é¢æ¸²æŸ“èˆ‡äº’å‹• ---

const tasksBody = document.getElementById('tasksBody');
const modal = document.getElementById('settingsModal');
const presetSelector = document.getElementById('presetSelector');

function renderSettings() {
    tasksBody.innerHTML = '';
    for (let i = 0; i < MAX_TASKS; i++) {
        const task = currentTasks[i] || { name: '', emoji: '', color: '#f0f0f0', start: 0, end: 0, enabled: false };
        // ä¿®æ­£ generateTimeSelectors å‡½æ•¸èª¿ç”¨ä½ç½®éŒ¯èª¤
        const startTimeSelectors = generateTimeSelectors(i, 'start', task.start, false);
        const endTimeSelectors = generateTimeSelectors(i, 'end', task.end, true); 

        let row = `<tr>
            <td>${i + 1}</td>
            <td><input type="checkbox" data-index="${i}" data-field="enabled" ${task.enabled ? 'checked' : ''}></td>
            <td><input type="text" data-index="${i}" data-field="name" value="${task.name || ''}" placeholder="ä¾‹å¦‚: åƒæ—©é¤"></td>
            <td><input type="text" data-index="${i}" data-field="emoji" value="${task.emoji || ''}" maxlength="2" style="width: 50px;" placeholder="åœ–ç¤º"></td>
            <td><input type="color" data-index="${i}" data-field="color" value="${task.color || '#f0f0f0'}"></td>
            <td>${startTimeSelectors}</td>
            <td>${endTimeSelectors}</td>
        </tr>`;
        tasksBody.innerHTML += row;
    }
    renderPresetSelector();
    updateSyncUrlDisplay(); 
}

async function applySettings() {
    const newTasks = [];
    let isValid = true;
    
    tasksBody.querySelectorAll('tr').forEach((row, i) => {
        const enabled = row.querySelector('[data-field="enabled"]').checked;
        const name = row.querySelector('[data-field="name"]').value.trim();
        const emoji = row.querySelector('[data-field="emoji"]').value.trim();
        const color = row.querySelector('[data-field="color"]').value;
        
        const startHourElement = row.querySelector('[data-field="startHour"]');
        const startMinuteElement = row.querySelector('[data-field="startMinute"]');
        const endHourElement = row.querySelector('[data-field="endHour"]');
        const endMinuteElement = row.querySelector('[data-field="endMinute"]');
        
        if (!startHourElement || !startMinuteElement || !endHourElement || !endMinuteElement) {
             console.error(`Missing time selector element on row ${i + 1}`);
             isValid = false;
             return;
        }

        const startHour = parseInt(startHourElement.value, 10);
        const startMinute = parseInt(startMinuteElement.value, 10);
        const endHour = parseInt(endHourElement.value, 10);
        const endMinute = parseInt(endMinuteElement.value, 10);
        
        const startMinutes = (startHour * 60) + startMinute;
        let endMinutes = (endHour * 60) + endMinute;

        if (endHour === 24) {
            endMinutes = FULL_DAY_MINUTES; 
        }

        const task = { enabled, name, emoji, color, start: startMinutes, end: endMinutes };
        
        if (task.enabled) {
            if (!task.name) {
                alert(`ç¬¬ ${i + 1} è¡Œå·²å•Ÿç”¨ï¼Œä½†ä»»å‹™åç¨±ä¸èƒ½ç‚ºç©ºï¼`);
                isValid = false;
                return;
            }
            if (task.start === task.end && (task.start !== 0 && task.end !== FULL_DAY_MINUTES)) {
                 alert(`ç¬¬ ${i + 1} è¡Œçš„æ™‚é–“å€é–“ç„¡æ•ˆ (é–‹å§‹/çµæŸæ™‚é–“ç›¸åŒ)ï¼`);
                 isValid = false;
                 return;
            }
        }
        newTasks.push(task);
    });

    if (!isValid) return false; 

    currentTasks = newTasks;
    
    // å‘¼å«é›²ç«¯å„²å­˜
    const saved = await saveCloudData(currentTasks, presets);

    if (saved) {
        updateTime(); 
        modal.style.display = 'none'; 
        alert('âœ… è¨­å®šå·²å„²å­˜ä¸¦åŒæ­¥åˆ°é›²ç«¯ï¼');
        return true;
    }
    return false; 
}

function renderPresetSelector() {
    presetSelector.innerHTML = '';
    const names = Object.keys(presets);
    if (names.length === 0) {
        presetSelector.innerHTML = '<option>ç„¡è¨˜æ†¶çµ„</option>';
        document.getElementById('loadPresetBtn').disabled = true;
        document.getElementById('deletePresetBtn').disabled = true;
        return;
    }
    document.getElementById('loadPresetBtn').disabled = false;
    document.getElementById('deletePresetBtn').disabled = false;
    
    names.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        presetSelector.appendChild(option);
    });
}

// --- åˆå§‹åŒ–èˆ‡äº‹ä»¶ç›£è½ ---

document.addEventListener('DOMContentLoaded', async () => {
    // éåŒæ­¥è¼‰å…¥æ•¸æ“š
    await loadData(); 
    
    updateModeButton(); 
    renderClock();
    
    function animate() {
        updateTime();
        // ç¢ºä¿æ¯ç§’æ›´æ–°ä¸€æ¬¡æ™‚é–“
        requestAnimationFrame(animate); 
    }
    requestAnimationFrame(animate);

    // é–‹å•Ÿè¨­å®š 
    document.getElementById('settingsBtn').addEventListener('click', () => {
        try {
            renderSettings();
            modal.style.display = 'flex';
        } catch (error) {
            console.error("é–‹å•Ÿè¨­å®šå½ˆçª—æ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
            // é¿å…å½ˆçª—é–‹å•Ÿå¤±æ•—ï¼Œå¼·è¡Œæ‰“é–‹ä¸¦é¡¯ç¤ºéŒ¯èª¤æç¤º
            modal.style.display = 'flex'; 
            alert("âš ï¸ é–‹å•Ÿè¨­å®šç™¼ç”Ÿåš´é‡éŒ¯èª¤ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ§åˆ¶å° (Console)ã€‚");
        }
    });
    
    document.getElementById('closeSettingsBtn').addEventListener('click', () => { modal.style.display = 'none'; });
    document.getElementById('saveSettingsBtn').addEventListener('click', applySettings);

    // æ¨¡å¼åˆ‡æ› (å¼·åˆ¶æ‰‹å‹•åˆ‡æ›)
    document.getElementById('modeToggleButton').addEventListener('click', () => {
        if (controlMode === MODE_FORCED_FULL) {
            controlMode = MODE_AUTO; 
        } else {
            controlMode = MODE_FORCED_FULL; 
        }
        saveControlMode(); 
        updateTime(); 
    });

    // è¼‰å…¥è¨˜æ†¶çµ„
    document.getElementById('loadPresetBtn').addEventListener('click', () => {
        const name = presetSelector.value;
        if (confirm(`ç¢ºå®šè¦è¼‰å…¥ã€Œ${name}ã€å—ï¼Ÿç›®å‰çš„è¨­å®šå°‡æœƒè¢«è¦†è“‹ï¼`)) {
            currentTasks = JSON.parse(JSON.stringify(presets[name])); 
            renderSettings();
            alert('è¨˜æ†¶çµ„è¼‰å…¥æˆåŠŸï¼è«‹é»æ“Šã€Œå„²å­˜ä¸¦æ›´æ–°ã€åŒæ­¥åˆ°é›²ç«¯ã€‚');
        }
    });

    // å„²å­˜è¨˜æ†¶çµ„ (éœ€åŒæ­¥åˆ°é›²ç«¯)
    document.getElementById('savePresetBtn').addEventListener('click', async () => {
        const nameInput = document.getElementById('newPresetName');
        const name = nameInput.value.trim();
        if (!name) { alert('è«‹è¼¸å…¥è¨˜æ†¶çµ„åç¨±ï¼'); return; }
        if (presets[name] && !confirm(`è¨˜æ†¶çµ„ã€Œ${name}ã€å·²å­˜åœ¨ï¼Œç¢ºå®šè¦è¦†è“‹å—ï¼Ÿ`)) { return; }
        
        const applied = await applySettings(); 
        if (!applied) return; 
        
        presets[name] = JSON.parse(JSON.stringify(currentTasks)); 
        const saved = await saveCloudData(currentTasks, presets);
        
        if (saved) {
            renderPresetSelector();
            nameInput.value = '';
            alert(`âœ… ä½œæ¯å·²æˆåŠŸå„²å­˜ç‚ºè¨˜æ†¶çµ„ã€Œ${name}ã€ä¸¦åŒæ­¥åˆ°é›²ç«¯ï¼`);
        }
    });

    // åˆªé™¤è¨˜æ†¶çµ„ (éœ€åŒæ­¥åˆ°é›²ç«¯)
    document.getElementById('deletePresetBtn').addEventListener('click', async () => {
        const name = presetSelector.value;
        if (confirm(`ç¢ºå®šè¦åˆªé™¤è¨˜æ†¶çµ„ã€Œ${name}ã€å—ï¼Ÿæ­¤æ“ä½œä¸å¯å¾©åŸï¼`)) {
            delete presets[name];
            const saved = await saveCloudData(currentTasks, presets);
            
            if (saved) {
                renderPresetSelector();
                alert('âœ… è¨˜æ†¶çµ„å·²åˆªé™¤ä¸¦åŒæ­¥åˆ°é›²ç«¯ã€‚');
            }
        }
    });
});
</script>

</body>
</html>
